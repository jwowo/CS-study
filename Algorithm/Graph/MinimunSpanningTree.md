## MST ( 최소 신장 트리, Minmum Spaning Tree )


### Greedy 알고리즘
- 최종 해답을 찾기 위해서 각 단계마다 하나의 답을 고름
- 각 단계에서 갑을 고를 때 가장 좋아 보이는 답 선택
- 최적화 문제에서
  - 선택할 당시에는 최적의 답을 고르지만 (locaaly optimal)
  - 최종 해답이 반드시 최적임을 보장하지 않음 (globally optimal not guaranteed)
  - 따라서 검증이 필요하다.

### Greedy 알고리즘의 설계 전략
- 공집합에서 시작
- 선택 과정 : 집합에 추가할 다음 최적의 원소를 고른다
- 적절성 검사 : 새로운 집합이 해답으로 적절한지 검사한다
- 해답 점검 : 새로운 집합이 문제의 해답인지 판단한다

### Greedy 알고리즘의 장단점
- 장점 : 상대적으로 설계하기가 매우 쉽다
- 단점 : 최적화 문제에서 반드시 정확성을 증명해야 한다.

### Kruskal 알고리즘

탐욕적인 방법(Greedy method)을 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소비용으로 연결하는 최적 해답을 구하는 것
- Kruskal 알고리즘은 최적의 해답을 주는 것으로 증명되었다.

### Kruskal 알고리즘 동작

1. 그래프의 간선들을 가중치의 오름차순으로 정렬
2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 안는 간선을 선택
   - 가장 낮은 가중치를 먼저 선택
   - 사이클을 형성하는 간선 제외
3. 해당 간선을 현재의 MST(최소 비용 신장 트리)의 집합에 추가

### Kruskal 동작 예시
![Kruskal 알고리즘 동작](../src/kruskal_algorithm.png)

#### 주의
- 다음 간선을 이미 선택된 간선들의 집합에 추가할 때 사이클을 생성하는지 체크
  - 새로운 간선이 이미 다른 경로에 의해 연결되어 있는 정점들을 연결할 떄 사이클이 형성됨
  - 추가할 새로운 간선의 양끝 정점이 같은 집합에 속해 있으면 사이클이 형성됨
사이클 생성 여부를 확인하는 방법
  - 추가하고자 하는 간선의 양끝 정점이 같은 집합에 속해 있는지를 먼저 검사해야 한다.
  - 'union-find 알고리즘' 이용




### 서로소 집합
- 서로소 집합(Disjoint Sets)란 공통 원소가 없는 두 집합
  - {1, 2} 와 {3, 4} 는 서로소 관계이다
  - {1, 2} 와 {2, 3} 은 서로소 관계가 아니다

### 서로소 집합 자료구조
- 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
- 서로소 집합 자료구조는 두 종류의 연산을 지원한다
  - 합집합(Union) : 두 개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
  - 찾기(Find) : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
  두개의 원소가 있을때 이 두 원소가 같은 집합에 있는지를 찾기 연산을 통해 알 수 있다.
- 서로소 집합 자료구조는 합치기 찾기(Union Find) 자료구조라고 불리기도 한다.

- 여러 개의 합치기 연산이 주어졌을 때 서로소 집합 자료구조의 동작과정은 다음과 같다.
  1. 합집합(Union) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.
    1) A와 B의 루트 노드 A^1, B^1를 각각 찾는다.
    2) A^1를 B^1의 부모 노드로 설정한다.
  2. 모든 합집합(Union) 연산을 처리할 때까지 1번의 과정을 반복한다.

### 서로소 집합 자료구조 : 동작


### 서로소 집합 자료구조 : 연결성
연결성을 통해 쉽게 집합의 형태를 확인할 수 있다

- 기본적인 형태의 서로소 집합 자ㅛ구조에서는 루트 노드에 즉시 접근할 수 없다.
  - 루트 노드를 찾기 위해 재귀적으로 부모 테이블을 계속 확인하며 거슬러 올라가야한다.

```python
# 특정 원소가 속한 집합을 찾기
# parent : 부모 테이블
# x : 노드의 인덱스
def find_parent(parent, x):
    # 루트 노드를 찾을 때까지 재귀 호출
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return x

# 두 원소가 속한 집합을 합치기
# parent : 각 인덱스 별로 부모의 인덱스 번호가 저장되어있는 리스트
# a, b : 합치려고 하는 두 노드의 인덱스 번호
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    # 관행적으로 값이 더 큰 노드가 작은 노드를  부모로 설정한다.
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
 
```

### 서로소 집합 자료구조 : 기본적인 구현 방법의 문제점
- 합집합(Union) 연산이 편향되게 이루어지는 경우 찾기(Find) 함수가 비효율적으로 동작
- 최악의 경우에는 찾기(Find) 함수가 모든 노드를 다 확인하게 되어 시간 복잡도가 O(V)이다. 

### 서로소 집합 자료구조 : 경로 압축
- 찾기(Find) 함수를 최적하기 위한 방법으로 경로 압축(Path Compression) 이용 가능
- 찾기(Find) 함수를 재귀적으로 호출한 뒤에 부모 테이블의 값을 바로 갱신한다.

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드를 찾을 때까지 재귀 호출
    # find_parent()를 실행하면 부모 테이블의 값이 자신의 루트가 되도록 설정한다.
    if parent[x] != x:
        parent[x] find_parent(parent, parent[x])
    return parent[x]
```

- 각 노드에 대하여 찾기(Find) 함수를 호출한 이후에 해당 노드의 ㅜ트 노드가 바로 부모 노드가 된다.
- 기본적인 방법에 비해 시간 복잡도가 개선된다.


### 서로소 집합을 활용한 사이클 판별
- 서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용가능
  - 방향 그래프에서의 사이클 여부는 DFS를 이용하여 판별 가능
- 사이클 판별 알고리즘은 다음과 같다
  1. 각 간선을 하나씩 확인하며 두 노드의 루트 노드를 확인한다
     1) 루트 노드가 서로 다르다면 두 노드에 대하여 합집합(Union) 연산을 수행한다.
     2) 루트 노드가 서로 같다면 사이클(Cycle)이 발생한 것이다.
  2. 그래프에 포함되어 있는 모든 간선에 대하여 1번의 과정을 반복한다
